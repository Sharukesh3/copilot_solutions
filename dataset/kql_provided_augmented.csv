Index,kql,context
0,"SecurityIncident
| where ModifiedBy == ""parth.test@pcsassure.me""
| where CreatedTime >= ago(30d) or LastModifiedTime >= ago(30d)
| project IncidentName, Title, Description, CreatedTime, LastModifiedTime, Status
","

The KQL query is designed to retrieve specific security incidents from the SecurityIncident table, focusing on those modified by a particular user within the last 30 days. Here's a breakdown of the query's structure and purpose:

1. **Table Selection**: The query targets the `SecurityIncident` table, which contains data related to security incidents.

2. **Filter by User**: The first `where` clause filters incidents to include only those modified by the user with the email `parth.test@pcsassure.me`.

3. **Time Filter**: The second `where` clause further filters incidents based on time. It includes incidents where either the `CreatedTime` or `LastModifiedTime` is within the last 30 days. This means any incident created or modified recently by the specified user is included.

4. **Projection of Fields**: The `project` statement selects specific fields to display: `IncidentName`, `Title`, `Description`, `CreatedTime`, `LastModifiedTime`, and `Status`.

**Purpose and Use Case**: This query is useful for auditing or monitoring recent activity by a specific user in a security context. It helps track changes or creations made by the user within the past month, which can be crucial for security audits or troubleshooting.

**Note on Logic**: The use of `or` in the time filter ensures a broader inclusion of incidents, capturing any that were either created or modified recently. If the intention was to include only incidents both created and modified within 30 days, using `and` would be appropriate. However, the current setup effectively captures all relevant recent activities by the user."
1,"WindowsFirewall
| where CommunicationDirection == ""RECEIVE""
| summarize UniquePorts = dcount(DestinationPort) by SourceIP, bin(TimeGenerated, 1m)
| where UniquePorts > 10
| project TimeGenerated, SourceIP, UniquePorts
","

The KQL query is designed to identify potential network reconnaissance or scanning activities by analyzing Windows Firewall logs. Here's a breakdown of the query's purpose and functionality:

1. **Data Source**: The query targets the `WindowsFirewall` table, which contains logs of firewall events.

2. **Filtering Incoming Traffic**: The `where CommunicationDirection == ""RECEIVE""` line filters the data to include only incoming traffic events.

3. **Aggregation and Grouping**: The `summarize` operator is used to count the number of distinct destination ports (`dcount(DestinationPort)`) for each source IP address (`SourceIP`) within one-minute intervals (`bin(TimeGenerated, 1m)`).

4. **Threshold Filtering**: The subsequent `where UniquePorts > 10` filters the results to include only those source IPs that have connected to more than 10 unique ports within a minute, which could indicate unusual activity.

5. **Result Projection**: The `project` operator selects the relevant columns (`TimeGenerated`, `SourceIP`, `UniquePorts`) to display the time of the event, the source IP address, and the count of unique ports used.

**Conclusion**: This query helps in detecting potential network scanning by identifying source IPs that connect to an unusually high number of ports within a short time frame, which could be indicative of malicious activity."
2,"SecurityAlert
| where ProductName == ""Microsoft Sentinel""
| summarize AlertCount = count() by AlertName
| project AlertName, AlertCount
","

The KQL query you've provided is designed to analyze security alerts generated by Microsoft Sentinel. Here's a breakdown of how it works and what it achieves:

1. **Data Source**: The query begins by accessing the `SecurityAlert` table, which contains records of all security-related alerts.

2. **Filtering**: The `where` clause filters these records to include only those alerts where the `ProductName` is ""Microsoft Sentinel"". This ensures that the analysis focuses solely on alerts from this specific product, excluding any others that might be present in the table.

3. **Aggregation**: The `summarize` operator is then used to count the occurrences of each unique alert. By using `count()` and grouping `by AlertName`, the query aggregates the data to show how many times each specific alert has been triggered.

4. **Projection**: Finally, the `project` operator selects only the `AlertName` and `AlertCount` columns to be included in the output. This simplifies the result set, making it easier to interpret the frequency of each alert.

**Use Case**: This query is particularly useful for monitoring and analyzing alert volumes. It helps in identifying which alerts are most frequent, aiding in prioritizing investigations or troubleshooting efforts.

**Considerations**: 
- The query uses exact string matching with `==`, so ensure the product name is correctly capitalized.
- Performance could be a consideration with large datasets; optimizing with additional filters (like time ranges) might be necessary.

In summary, this query efficiently extracts and summarizes alert data from Microsoft Sentinel, providing insights into alert frequency and helping in proactive security management."
3,"Usage
| where TimeGenerated >= ago(48h)
| where IsBillable == true
| where Solution == ""SecurityInsights""
| project TimeGenerated, DataType, Quantity, _BilledSize
","

The KQL query you're examining is designed to retrieve specific usage data from the ""Usage"" table, applying several filters and selecting particular columns. Here's a breakdown of the query's components and their functions:

1. **Table Selection**: The query starts by targeting the ""Usage"" table, which contains usage data.

2. **Time Filter**: The first filter uses `where TimeGenerated >= ago(48h)` to include only records from the last 48 hours. The `ago()` function calculates the time 48 hours before the current time.

3. **Billable Filter**: The second filter, `where IsBillable == true`, ensures that only records where the service is billable are included.

4. **Solution Filter**: The third filter, `where Solution == 'SecurityInsights'`, narrows the data to records associated with the 'SecurityInsights' solution, likely referring to Azure Security Insights.

5. **Column Selection**: The `project` operator selects four columns for the output: `TimeGenerated`, `DataType`, `Quantity`, and `_BilledSize`. This tailors the result to include only the relevant information.

**Understanding the Fields**:
- **TimeGenerated**: The timestamp when the record was generated.
- **IsBillable**: A boolean indicating if the usage is billable.
- **Solution**: Specifies the solution, in this case, 'SecurityInsights'.
- **DataType**: The type of data being recorded.
- **Quantity**: Likely represents the amount of usage, such as hours or bytes.
- **_BilledSize**: Probably a system-generated field indicating the size billed, possibly in bytes.

**Considerations**:
- The `ago(48h)` function is case-insensitive and includes exactly 48 hours ago up to the current time.
- Performance may be optimized if the filtered fields are indexed, though specifics depend on the KQL environment.

This query efficiently retrieves recent, billable usage data specific to Azure Security Insights, selecting only the necessary columns for analysis."
4,"SecurityIncident
| where TimeGenerated >= ago(2d)
","

The KQL query provided is designed to retrieve security incidents from the last two days. Here's a breakdown of the query and its implications:

1. **Table Selection**: The query accesses the `SecurityIncident` table, which stores security-related events.

2. **Filtering**: The `where` operator filters records based on the `TimeGenerated` field, which is a timestamp indicating when each incident occurred.

3. **Time Frame**: The `ago(2d)` function calculates the time two days before the query execution, ensuring only incidents from the past 48 hours are included.

4. **Considerations**:
   - **Case Sensitivity**: KQL is case-sensitive for table and column names, so the correct casing must be used.
   - **Time Zone**: The `ago()` function uses UTC by default, which is important for consistent results across different time zones.
   - **Performance**: Filtering by `TimeGenerated` is efficient if the field is indexed, which is typical in Kusto.

5. **Extensions**: The query can be modified for different time frames (e.g., `ago(7d)` for a week) or additional filters for severity or type.

This query is effective for monitoring recent security events, providing a focused dataset for analysis."
5,"CommonSecurityLog
| where DeviceVendor == ""Fortinet""
| where EventOutcome == ""success""
| where Message contains ""VPN""
| project TimeGenerated, SourceIP, DestinationIP, EventOutcome, Message
","

The KQL query is designed to retrieve specific security logs from a table named `CommonSecurityLog`. Here's a breakdown of the query's components and their functions:

1. **Table Selection**: The query starts by accessing the `CommonSecurityLog` table, which contains security-related data.

2. **Filtering by Device Vendor**: The first `where` clause filters the logs to include only those from devices manufactured by Fortinet, using `DeviceVendor == ""Fortinet""`.

3. **Filtering by Event Outcome**: The second `where` clause further filters the logs to include only successful events, using `EventOutcome == ""success""`.

4. **Filtering by Message Content**: The third `where` clause narrows down the logs to those where the message contains the word ""VPN"", indicating VPN-related activities.

5. **Selecting Output Columns**: The `project` command specifies the columns to display, including `TimeGenerated`, `SourceIP`, `DestinationIP`, `EventOutcome`, and `Message`.

This query effectively isolates successful VPN events from Fortinet devices, providing relevant details for analysis. The use of multiple `where` clauses is syntactically correct in KQL, though combining them into a single `where` statement could be considered for efficiency. String comparisons in KQL are case-sensitive by default."
6,"SecurityIncident
| where TimeGenerated >= ago(24h)
| mv-expand techniques = parse_json(tostring(AdditionalData.techniques))
| summarize Count = count() by tostring(techniques)
| top 1 by Count
","

The KQL query is designed to analyze security incidents within the last 24 hours to identify the most frequently used attack technique. Here's a breakdown of how it works:

1. **Data Source**: The query starts by accessing the `SecurityIncident` table, which contains records of security incidents.

2. **Time Filtering**: It filters these incidents to include only those that occurred within the past 24 hours using `where TimeGenerated >= ago(24h)`.

3. **Expanding Techniques**: The `mv-expand` operator is used to expand each item in the `AdditionalData.techniques` array into separate rows. This involves converting the array to a string, parsing it as JSON, and then expanding it.

4. **Counting Techniques**: The `summarize` operator groups the expanded techniques and counts their occurrences, showing how frequently each technique is used.

5. **Top Technique**: Finally, the `top 1 by Count` sorts these counts in descending order and retrieves the most common technique.

This query helps security analysts focus on the most prevalent attack techniques, enabling them to prioritize defensive measures effectively."
7,"Analytics workspace
let timePeriod = 24h;
let totalSeconds = toscalar(range x from 0 to timePeriod / 1s step 1 | summarize count());
Usage
| where TimeGenerated >= ago(timePeriod)
| summarize TotalDataIngestedMB = sum(Quantity)
| extend TotalDataIngestedBytes = TotalDataIngestedMB * 1024 * 1024
| extend AverageIngestionRatePerSecond = TotalDataIngestedBytes / totalSeconds
| project AverageIngestionRatePerSecond
","

The KQL query calculates the average data ingestion rate per second over the past 24 hours. Here's a breakdown of how it works:

1. **Define Time Period**: The query starts by setting a 24-hour window using `let timePeriod = 24h;`.

2. **Calculate Total Seconds**: It computes the total number of seconds in 24 hours (86,400) using a range and `toscalar` to get a single value.

3. **Filter and Sum Data**: The query then filters data from the `Usage` table where `TimeGenerated` is within the last 24 hours. It sums the `Quantity` in MB to get the total data ingested.

4. **Convert to Bytes**: The total MB is converted to bytes by multiplying by 1024 twice.

5. **Compute Average Rate**: The average ingestion rate per second is found by dividing the total bytes by the total seconds.

6. **Output Result**: Finally, the query projects only the average rate, providing a clean result.

This approach efficiently handles potential large datasets and adapts if the time window changes, ensuring accurate and flexible results."
